---
// Audio visualization page
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Audio Visualization - AI Video</title>
		<script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.7/dist/umd/ffmpeg.js"></script>
		<style>
			body {
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
				margin: 0;
				padding: 0;
				background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
				min-height: 100vh;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				color: white;
			}
			
			.container {
				text-align: center;
				max-width: 1200px;
				padding: 2rem;
			}
			
			h1 {
				font-size: 2.5rem;
				margin-bottom: 1rem;
				font-weight: 700;
			}
			
			.description {
				font-size: 1.1rem;
				margin-bottom: 2rem;
				opacity: 0.9;
			}
			
			.controls {
				margin-bottom: 2rem;
				display: flex;
				gap: 1rem;
				justify-content: center;
				flex-wrap: wrap;
			}
			
			.theme-selector {
				margin-bottom: 2rem;
				display: flex;
				gap: 1rem;
				justify-content: center;
				flex-wrap: wrap;
			}
			
			.export-controls {
				margin-bottom: 2rem;
				display: flex;
				gap: 1rem;
				justify-content: center;
				flex-wrap: wrap;
			}
			
			.theme-btn {
				background: rgba(255, 255, 255, 0.2);
				border: 2px solid rgba(255, 255, 255, 0.3);
				color: white;
				padding: 0.75rem 1.5rem;
				border-radius: 8px;
				font-size: 1rem;
				cursor: pointer;
				transition: all 0.3s ease;
				backdrop-filter: blur(10px);
			}
			
			.theme-btn:hover {
				background: rgba(255, 255, 255, 0.3);
				border-color: rgba(255, 255, 255, 0.5);
				transform: translateY(-2px);
			}
			
			.theme-btn.active {
				background: rgba(255, 255, 255, 0.4);
				border-color: rgba(255, 255, 255, 0.8);
				box-shadow: 0 4px 20px rgba(255, 255, 255, 0.3);
			}
			
			.export-btn {
				background: linear-gradient(135deg, #ff6b6b, #ee5a24);
				border: 2px solid rgba(255, 255, 255, 0.3);
				color: white;
				padding: 0.75rem 1.5rem;
				border-radius: 8px;
				font-size: 1rem;
				cursor: pointer;
				transition: all 0.3s ease;
				backdrop-filter: blur(10px);
				font-weight: 600;
			}
			
			.export-btn:hover {
				background: linear-gradient(135deg, #ff5252, #d63031);
				border-color: rgba(255, 255, 255, 0.5);
				transform: translateY(-2px);
				box-shadow: 0 4px 20px rgba(255, 107, 107, 0.3);
			}
			
			.export-btn:disabled {
				opacity: 0.5;
				cursor: not-allowed;
				transform: none;
				background: rgba(255, 255, 255, 0.2);
			}
			
			button {
				background: rgba(255, 255, 255, 0.2);
				border: 2px solid rgba(255, 255, 255, 0.3);
				color: white;
				padding: 0.75rem 1.5rem;
				border-radius: 8px;
				font-size: 1rem;
				cursor: pointer;
				transition: all 0.3s ease;
				backdrop-filter: blur(10px);
			}
			
			button:hover {
				background: rgba(255, 255, 255, 0.3);
				border-color: rgba(255, 255, 255, 0.5);
				transform: translateY(-2px);
			}
			
			button:disabled {
				opacity: 0.5;
				cursor: not-allowed;
				transform: none;
			}
			
			.file-input {
				display: none;
			}
			
			.file-label {
				background: rgba(255, 255, 255, 0.2);
				border: 2px solid rgba(255, 255, 255, 0.3);
				color: white;
				padding: 0.75rem 1.5rem;
				border-radius: 8px;
				font-size: 1rem;
				cursor: pointer;
				transition: all 0.3s ease;
				backdrop-filter: blur(10px);
				display: inline-block;
			}
			
			.file-label:hover {
				background: rgba(255, 255, 255, 0.3);
				border-color: rgba(255, 255, 255, 0.5);
				transform: translateY(-2px);
			}
			
			.canvas-container {
				background: rgba(0, 0, 0, 0.3);
				border-radius: 12px;
				padding: 1rem;
				margin-bottom: 2rem;
				backdrop-filter: blur(10px);
			}
			
			#canvas {
				border-radius: 8px;
				box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
				background: rgba(0, 0, 0, 0.8);
			}
			
			.audio-info {
				background: rgba(255, 255, 255, 0.1);
				padding: 1rem;
				border-radius: 8px;
				margin-bottom: 1rem;
				backdrop-filter: blur(10px);
			}
			
			.rms-display {
				font-size: 1.2rem;
				font-weight: 600;
				margin-bottom: 0.5rem;
			}
			
			.audio-status {
				font-size: 0.9rem;
				opacity: 0.8;
			}
			
			.export-status {
				background: rgba(255, 255, 255, 0.1);
				padding: 1rem;
				border-radius: 8px;
				margin-bottom: 1rem;
				backdrop-filter: blur(10px);
				display: none;
			}
			
			.progress-bar {
				width: 100%;
				height: 8px;
				background: rgba(255, 255, 255, 0.2);
				border-radius: 4px;
				overflow: hidden;
				margin-top: 0.5rem;
			}
			
			.progress-fill {
				height: 100%;
				background: linear-gradient(90deg, #4facfe, #00f2fe);
				width: 0%;
				transition: width 0.3s ease;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h1>Audio Visualization</h1>
			<p class="description">Upload an audio file and watch the canvas animate to the music's rhythm</p>
			
			<div class="theme-selector">
				<button class="theme-btn active" data-theme="neon">Neon</button>
				<button class="theme-btn" data-theme="retro">Retro</button>
				<button class="theme-btn" data-theme="minimal">Minimal</button>
				<button class="theme-btn" data-theme="cosmic">Cosmic</button>
				<button class="theme-btn" data-theme="fire">Fire</button>
			</div>
			
			<div class="controls">
				<input type="file" id="audioFile" class="file-input" accept="audio/*" />
				<label for="audioFile" class="file-label">Choose Audio File</label>
				<button id="playBtn" disabled>Play</button>
				<button id="pauseBtn" disabled>Pause</button>
				<button id="stopBtn" disabled>Stop</button>
			</div>
			
			<div class="export-controls">
				<button id="exportBtn" class="export-btn" disabled>Export Video</button>
				<button id="recordBtn" disabled>Start Recording</button>
				<button id="stopRecordBtn" disabled>Stop Recording</button>
			</div>
			
			<div class="audio-info">
				<div class="rms-display">RMS: <span id="rmsValue">0.00</span></div>
				<div class="audio-status" id="audioStatus">No audio loaded</div>
			</div>
			
			<div class="export-status" id="exportStatus">
				<div id="exportMessage">Preparing export...</div>
				<div class="progress-bar">
					<div class="progress-fill" id="progressFill"></div>
				</div>
			</div>
			
			<div class="canvas-container">
				<canvas id="canvas" width="800" height="400"></canvas>
			</div>
		</div>

		<script>
			// Audio context and analysis setup
			let audioContext;
			let audioSource;
			let analyser;
			let audioElement;
			let isPlaying = false;
			let audioSourceCreated = false;
			
			// Canvas setup
			let canvas;
			let ctx;
			let animationId;
			
			// Current theme
			let currentTheme = 'neon';
			
			// Recording and export setup
			let isRecording = false;
			let recordedFrames = [];
			let recordedAudio = [];
			let mediaRecorder;
			let recordedChunks = [];
			let ffmpeg;
			let recordingStartTime;
			let audioStream;
			let audioRecorder;
			
			// Theme configurations
			const themes = {
				neon: {
					name: 'Neon',
					background: 'rgba(0, 0, 0, 0.9)',
					circleColors: ['#ff00ff', '#00ffff', '#ffff00', '#ff0080', '#8000ff'],
					barColors: ['#00ff00', '#ff0000', '#0000ff', '#ffff00', '#ff00ff'],
					particleColors: ['#ff00ff', '#00ffff', '#ffff00', '#ff0080', '#8000ff'],
					effects: ['glow', 'pulse', 'trail']
				},
				retro: {
					name: 'Retro',
					background: 'rgba(20, 20, 20, 0.9)',
					circleColors: ['#ff6b35', '#f7931e', '#ffd23f', '#f4a261', '#e76f51'],
					barColors: ['#ff6b35', '#f7931e', '#ffd23f', '#f4a261', '#e76f51'],
					particleColors: ['#ff6b35', '#f7931e', '#ffd23f', '#f4a261', '#e76f51'],
					effects: ['scanlines', 'vintage', 'grain']
				},
				minimal: {
					name: 'Minimal',
					background: 'rgba(255, 255, 255, 0.95)',
					circleColors: ['#000000', '#333333', '#666666', '#999999', '#cccccc'],
					barColors: ['#000000', '#333333', '#666666', '#999999', '#cccccc'],
					particleColors: ['#000000', '#333333', '#666666', '#999999', '#cccccc'],
					effects: ['clean', 'simple', 'elegant']
				},
				cosmic: {
					name: 'Cosmic',
					background: 'rgba(10, 5, 30, 0.9)',
					circleColors: ['#4facfe', '#00f2fe', '#43e97b', '#38f9d7', '#fa709a'],
					barColors: ['#4facfe', '#00f2fe', '#43e97b', '#38f9d7', '#fa709a'],
					particleColors: ['#4facfe', '#00f2fe', '#43e97b', '#38f9d7', '#fa709a'],
					effects: ['stars', 'nebula', 'aurora']
				},
				fire: {
					name: 'Fire',
					background: 'rgba(20, 10, 5, 0.9)',
					circleColors: ['#ff4500', '#ff6347', '#ff7f50', '#ff8c00', '#ffa500'],
					barColors: ['#ff4500', '#ff6347', '#ff7f50', '#ff8c00', '#ffa500'],
					particleColors: ['#ff4500', '#ff6347', '#ff7f50', '#ff8c00', '#ffa500'],
					effects: ['flame', 'embers', 'smoke']
				}
			};
			
			// Visualization objects
			let circles = [];
			let bars = [];
			let particles = [];
			
			// DOM elements
			const playBtn = document.getElementById('playBtn');
			const pauseBtn = document.getElementById('pauseBtn');
			const stopBtn = document.getElementById('stopBtn');
			const fileInput = document.getElementById('audioFile');
			const rmsValue = document.getElementById('rmsValue');
			const audioStatus = document.getElementById('audioStatus');
			const themeBtns = document.querySelectorAll('.theme-btn');
			const exportBtn = document.getElementById('exportBtn');
			const recordBtn = document.getElementById('recordBtn');
			const stopRecordBtn = document.getElementById('stopRecordBtn');
			const exportStatus = document.getElementById('exportStatus');
			const exportMessage = document.getElementById('exportMessage');
			const progressFill = document.getElementById('progressFill');
			
			// Initialize FFmpeg
			async function initFFmpeg() {
				try {
					ffmpeg = createFFmpeg({ log: true });
					await ffmpeg.load();
					console.log('FFmpeg loaded successfully');
				} catch (error) {
					console.error('Error loading FFmpeg:', error);
				}
			}
			
			// Theme selection
			themeBtns.forEach(btn => {
				btn.addEventListener('click', () => {
					const theme = btn.dataset.theme;
					setTheme(theme);
					
					// Update active button
					themeBtns.forEach(b => b.classList.remove('active'));
					btn.classList.add('active');
				});
			});
			
			// Set theme function
			function setTheme(theme) {
				currentTheme = theme;
				const themeConfig = themes[theme];
				
				// Update visualization objects with new colors
				createVisualizationObjects();
				
				// Redraw with new theme
				draw();
				
				console.log(`Theme changed to: ${themeConfig.name}`);
			}
			
			// Initialize canvas
			function initCanvas() {
				canvas = document.getElementById('canvas');
				ctx = canvas.getContext('2d');
				
				// Create initial visualization objects
				createVisualizationObjects();
				
				console.log('Canvas initialized successfully');
			}
			
			// Create visualization objects
			function createVisualizationObjects() {
				const themeConfig = themes[currentTheme];
				
				// Create circles
				circles = [];
				for (let i = 0; i < 5; i++) {
					circles.push({
						x: 400,
						y: 200,
						radius: 20 + i * 10,
						scale: 1,
						rotation: 0,
						color: themeConfig.circleColors[i % themeConfig.circleColors.length],
						originalColor: themeConfig.circleColors[i % themeConfig.circleColors.length]
					});
				}
				
				// Create bars
				bars = [];
				for (let i = 0; i < 20; i++) {
					bars.push({
						x: 50 + i * 35,
						y: 350,
						width: 30,
						height: 50,
						color: themeConfig.barColors[i % themeConfig.barColors.length],
						originalColor: themeConfig.barColors[i % themeConfig.barColors.length]
					});
				}
				
				// Create particles
				particles = [];
				for (let i = 0; i < 50; i++) {
					particles.push({
						x: Math.random() * 800,
						y: Math.random() * 400,
						radius: 2 + Math.random() * 3,
						color: themeConfig.particleColors[i % themeConfig.particleColors.length],
						opacity: 0.6,
						trail: []
					});
				}
			}
			
			// Initialize audio context
			function initAudio() {
				try {
					audioContext = new (window.AudioContext || window.webkitAudioContext)();
					analyser = audioContext.createAnalyser();
					analyser.fftSize = 256;
					analyser.smoothingTimeConstant = 0.8;
					console.log('Audio context initialized successfully');
				} catch (error) {
					console.error('Error initializing audio context:', error);
					audioStatus.textContent = 'Error: Audio context not supported';
				}
			}
			
			// Handle file selection
			fileInput.addEventListener('change', (e) => {
				const file = e.target.files[0];
				if (file) {
					loadAudioFile(file);
				}
			});
			
			// Load audio file
			function loadAudioFile(file) {
				const url = URL.createObjectURL(file);
				audioElement = new Audio(url);
				audioElement.crossOrigin = 'anonymous';
				audioSourceCreated = false;
				
				audioElement.addEventListener('canplay', () => {
					audioStatus.textContent = `Loaded: ${file.name}`;
					playBtn.disabled = false;
					pauseBtn.disabled = true;
					stopBtn.disabled = true;
					recordBtn.disabled = false;
					console.log('Audio file loaded successfully');
				});
				
				audioElement.addEventListener('ended', () => {
					stopAudio();
				});
				
				audioElement.addEventListener('error', (e) => {
					console.error('Audio loading error:', e);
					audioStatus.textContent = 'Error loading audio file';
				});
			}
			
			// Play audio
			playBtn.addEventListener('click', () => {
				if (audioElement && !isPlaying) {
					playAudio();
				}
			});
			
			// Pause audio
			pauseBtn.addEventListener('click', () => {
				if (isPlaying) {
					pauseAudio();
				}
			});
			
			// Stop audio
			stopBtn.addEventListener('click', () => {
				if (isPlaying) {
					stopAudio();
				}
			});
			
			// Start recording
			recordBtn.addEventListener('click', () => {
				if (audioElement && !isRecording) {
					startRecording();
				}
			});
			
			// Stop recording
			stopRecordBtn.addEventListener('click', () => {
				if (isRecording) {
					stopRecording();
				}
			});
			
			// Export video
			exportBtn.addEventListener('click', () => {
				if (recordedFrames.length > 0) {
					exportVideo();
				}
			});
			
			// Start recording function
			async function startRecording() {
				try {
					recordedFrames = [];
					recordedAudio = [];
					recordingStartTime = Date.now();
					isRecording = true;
					
					recordBtn.disabled = true;
					stopRecordBtn.disabled = false;
					exportBtn.disabled = true;
					
					// Start playing audio if not already playing
					if (!isPlaying) {
						await playAudio();
					}
					
					// Capture audio stream from the audio element
					if (audioElement) {
						audioStream = audioElement.captureStream();
					}
					
					audioStatus.textContent = 'Recording...';
					console.log('Recording started');
				} catch (error) {
					console.error('Error starting recording:', error);
					audioStatus.textContent = 'Error starting recording';
				}
			}
			
			// Stop recording function
			function stopRecording() {
				isRecording = false;
				
				recordBtn.disabled = false;
				stopRecordBtn.disabled = true;
				exportBtn.disabled = false;
				
				audioStatus.textContent = 'Recording stopped';
				console.log(`Recording stopped. Captured ${recordedFrames.length} frames`);
			}
			
			// Export video function
			async function exportVideo() {
				if (!ffmpeg) {
					await initFFmpeg();
				}
				
				exportStatus.style.display = 'block';
				exportMessage.textContent = 'Preparing video export...';
				progressFill.style.width = '10%';
				
				try {
					// Convert frames to video
					exportMessage.textContent = 'Processing frames...';
					progressFill.style.width = '30%';
					
					// Create a video stream from recorded frames
					const fps = 30;
					const frameDuration = 1000 / fps; // milliseconds per frame
					
					// Convert canvas frames to image data
					const frameImages = [];
					for (let i = 0; i < recordedFrames.length; i++) {
						const frameCanvas = recordedFrames[i];
						const imageData = frameCanvas.toDataURL('image/png');
						frameImages.push(imageData);
					}
					
					progressFill.style.width = '50%';
					exportMessage.textContent = 'Creating video with audio...';
					
					// Create a combined stream with video and audio
					const videoStream = canvas.captureStream(fps);
					let combinedStream;
					
					if (audioStream) {
						// Combine video and audio streams
						const tracks = [
							...videoStream.getVideoTracks(),
							...audioStream.getAudioTracks()
						];
						combinedStream = new MediaStream(tracks);
					} else {
						combinedStream = videoStream;
					}
					
					const mediaRecorder = new MediaRecorder(combinedStream, {
						mimeType: 'video/webm;codecs=vp9,opus'
					});
					
					const chunks = [];
					
					mediaRecorder.ondataavailable = (event) => {
						if (event.data.size > 0) {
							chunks.push(event.data);
						}
					};
					
					mediaRecorder.onstop = async () => {
						const blob = new Blob(chunks, { type: 'video/webm' });
						
						// Convert to MP4 using FFmpeg
						try {
							exportMessage.textContent = 'Converting to MP4 with audio...';
							progressFill.style.width = '70%';
							
							// Write the video blob to FFmpeg
							ffmpeg.FS('writeFile', 'input.webm', await fetch(blob).then(r => r.arrayBuffer()));
							
							// Run FFmpeg command to convert to MP4 with audio
							await ffmpeg.run(
								'-i', 'input.webm',
								'-c:v', 'libx264',
								'-c:a', 'aac',
								'-preset', 'fast',
								'-crf', '23',
								'-b:a', '128k',
								'output.mp4'
							);
							
							// Read the output file
							const data = ffmpeg.FS('readFile', 'output.mp4');
							
							// Create download link
							const mp4Blob = new Blob([data.buffer], { type: 'video/mp4' });
							const url = URL.createObjectURL(mp4Blob);
							
							const link = document.createElement('a');
							link.download = `audio-viz-${currentTheme}-${Date.now()}.mp4`;
							link.href = url;
							link.click();
							
							// Clean up
							URL.revokeObjectURL(url);
							ffmpeg.FS('unlink', 'input.webm');
							ffmpeg.FS('unlink', 'output.mp4');
							
							exportMessage.textContent = 'MP4 with audio export completed!';
							progressFill.style.width = '100%';
							
							setTimeout(() => {
								exportStatus.style.display = 'none';
							}, 3000);
							
						} catch (error) {
							console.error('FFmpeg conversion error:', error);
							exportMessage.textContent = 'MP4 conversion failed, downloading WebM instead...';
							
							// Fallback to WebM download
							const url = URL.createObjectURL(blob);
							const link = document.createElement('a');
							link.download = `audio-viz-${currentTheme}-${Date.now()}.webm`;
							link.href = url;
							link.click();
							
							URL.revokeObjectURL(url);
							
							setTimeout(() => {
								exportStatus.style.display = 'none';
							}, 3000);
						}
					};
					
					// Start recording the combined stream
					mediaRecorder.start();
					
					// Replay the recorded frames at the correct frame rate
					let frameIndex = 0;
					const replayInterval = setInterval(() => {
						if (frameIndex < recordedFrames.length) {
							// Draw the recorded frame to the canvas
							const frameCanvas = recordedFrames[frameIndex];
							ctx.clearRect(0, 0, 800, 400);
							ctx.drawImage(frameCanvas, 0, 0);
							frameIndex++;
						} else {
							clearInterval(replayInterval);
							mediaRecorder.stop();
						}
					}, frameDuration);
					
				} catch (error) {
					console.error('Error exporting video:', error);
					exportMessage.textContent = 'Export failed: ' + error.message;
					
					setTimeout(() => {
						exportStatus.style.display = 'none';
					}, 3000);
				}
			}
			
			// Play audio function
			async function playAudio() {
				try {
					if (!audioContext) {
						initAudio();
					}
					
					if (audioContext.state === 'suspended') {
						await audioContext.resume();
					}
					
					// Only create MediaElementSource once per audio element
					if (!audioSourceCreated) {
						audioSource = audioContext.createMediaElementSource(audioElement);
						audioSource.connect(analyser);
						analyser.connect(audioContext.destination);
						audioSourceCreated = true;
						console.log('Audio source connected to analyzer');
					}
					
					await audioElement.play();
					isPlaying = true;
					
					playBtn.disabled = true;
					pauseBtn.disabled = false;
					stopBtn.disabled = false;
					
					audioStatus.textContent = 'Playing...';
					
					// Start animation
					animate();
				} catch (error) {
					console.error('Error playing audio:', error);
					audioStatus.textContent = 'Error playing audio';
				}
			}
			
			// Pause audio function
			function pauseAudio() {
				audioElement.pause();
				isPlaying = false;
				
				playBtn.disabled = false;
				pauseBtn.disabled = true;
				stopBtn.disabled = false;
				
				audioStatus.textContent = 'Paused';
				
				// Stop animation
				if (animationId) {
					cancelAnimationFrame(animationId);
				}
			}
			
			// Stop audio function
			function stopAudio() {
				audioElement.pause();
				audioElement.currentTime = 0;
				isPlaying = false;
				
				playBtn.disabled = false;
				pauseBtn.disabled = true;
				stopBtn.disabled = true;
				
				audioStatus.textContent = 'Stopped';
				
				// Stop animation
				if (animationId) {
					cancelAnimationFrame(animationId);
				}
				
				// Reset visualization
				resetVisualization();
			}
			
			// Reset visualization to initial state
			function resetVisualization() {
				createVisualizationObjects();
				draw();
				rmsValue.textContent = '0.00';
			}
			
			// Apply theme-specific effects
			function applyThemeEffects(rms) {
				const themeConfig = themes[currentTheme];
				
				switch (currentTheme) {
					case 'neon':
						// Add glow effect
						ctx.shadowBlur = 20;
						ctx.shadowColor = '#ff00ff';
						break;
					case 'retro':
						// Add scanlines
						ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
						ctx.lineWidth = 1;
						for (let i = 0; i < 400; i += 4) {
							ctx.beginPath();
							ctx.moveTo(0, i);
							ctx.lineTo(800, i);
							ctx.stroke();
						}
						break;
					case 'minimal':
						// Clean, simple style
						ctx.shadowBlur = 0;
						break;
					case 'cosmic':
						// Add stars
						ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
						for (let i = 0; i < 100; i++) {
							const x = (i * 137.5) % 800;
							const y = (i * 97.3) % 400;
							const size = Math.sin(Date.now() * 0.001 + i) * 2 + 1;
							ctx.beginPath();
							ctx.arc(x, y, size, 0, Math.PI * 2);
							ctx.fill();
						}
						break;
					case 'fire':
						// Add flame effect
						ctx.shadowBlur = 15;
						ctx.shadowColor = '#ff4500';
						break;
				}
			}
			
			// Draw function
			function draw() {
				const themeConfig = themes[currentTheme];
				
				// Clear canvas with theme background
				ctx.fillStyle = themeConfig.background;
				ctx.fillRect(0, 0, 800, 400);
				
				// Apply theme effects
				applyThemeEffects();
				
				// Draw circles
				circles.forEach(circle => {
					ctx.save();
					ctx.translate(circle.x, circle.y);
					ctx.rotate(circle.rotation);
					ctx.scale(circle.scale, circle.scale);
					
					ctx.beginPath();
					ctx.arc(0, 0, circle.radius, 0, Math.PI * 2);
					ctx.fillStyle = circle.color;
					ctx.fill();
					
					ctx.restore();
				});
				
				// Draw bars
				bars.forEach(bar => {
					ctx.fillStyle = bar.color;
					ctx.fillRect(bar.x - bar.width/2, bar.y - bar.height, bar.width, bar.height);
				});
				
				// Draw particles with trails
				particles.forEach(particle => {
					// Draw trail
					if (particle.trail.length > 0) {
						ctx.strokeStyle = particle.color;
						ctx.lineWidth = 2;
						ctx.globalAlpha = 0.3;
						ctx.beginPath();
						ctx.moveTo(particle.trail[0].x, particle.trail[0].y);
						for (let i = 1; i < particle.trail.length; i++) {
							ctx.lineTo(particle.trail[i].x, particle.trail[i].y);
						}
						ctx.stroke();
					}
					
					// Draw particle
					ctx.globalAlpha = particle.opacity;
					ctx.fillStyle = particle.color;
					ctx.beginPath();
					ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
					ctx.fill();
				});
				
				ctx.globalAlpha = 1;
				ctx.shadowBlur = 0;
			}
			
			// Main animation loop
			function animate() {
				if (!isPlaying || !analyser) return;
				
				const bufferLength = analyser.frequencyBinCount;
				const dataArray = new Uint8Array(bufferLength);
				analyser.getByteFrequencyData(dataArray);
				
				// Calculate RMS value
				let sum = 0;
				for (let i = 0; i < bufferLength; i++) {
					sum += dataArray[i] * dataArray[i];
				}
				const rms = Math.sqrt(sum / bufferLength) / 255;
				
				// Update RMS display
				rmsValue.textContent = rms.toFixed(3);
				
				// Capture frame if recording
				if (isRecording) {
					const frameCanvas = document.createElement('canvas');
					frameCanvas.width = 800;
					frameCanvas.height = 400;
					const frameCtx = frameCanvas.getContext('2d');
					frameCtx.drawImage(canvas, 0, 0);
					recordedFrames.push(frameCanvas);
				}
				
				// Debug: log RMS value occasionally
				if (Math.random() < 0.01) {
					console.log('RMS:', rms, 'Max frequency:', Math.max(...dataArray));
				}
				
				// Animate circles based on RMS
				circles.forEach((circle, i) => {
					circle.scale = 1 + rms * (i + 1) * 0.5;
					circle.rotation += rms * 0.1 * (i + 1);
					
					// Theme-specific circle effects
					if (currentTheme === 'neon') {
						circle.color = `hsl(${200 + i * 30 + rms * 100}, 70%, 60%)`;
					} else if (currentTheme === 'fire') {
						circle.color = `hsl(${20 + rms * 40}, 100%, ${50 + rms * 30}%)`;
					}
				});
				
				// Animate bars based on frequency data
				bars.forEach((bar, i) => {
					const frequencyIndex = Math.floor(i * bufferLength / bars.length);
					const frequencyValue = dataArray[frequencyIndex] / 255;
					bar.height = 50 + frequencyValue * 200;
					
					// Theme-specific bar effects
					if (currentTheme === 'neon') {
						bar.color = `hsl(${180 + frequencyValue * 180}, 80%, 60%)`;
					} else if (currentTheme === 'fire') {
						bar.color = `hsl(${20 + frequencyValue * 40}, 100%, ${50 + frequencyValue * 30}%)`;
					} else {
						bar.color = bar.originalColor;
					}
				});
				
				// Animate particles
				particles.forEach((particle, i) => {
					const speed = rms * 5;
					const angle = (i * 137.5 + Date.now() * 0.001) % (Math.PI * 2);
					
					// Add current position to trail
					particle.trail.push({ x: particle.x, y: particle.y });
					if (particle.trail.length > 10) {
						particle.trail.shift();
					}
					
					particle.x += Math.cos(angle) * speed;
					particle.y += Math.sin(angle) * speed;
					
					// Wrap particles around screen
					if (particle.x < 0) particle.x = 800;
					if (particle.x > 800) particle.x = 0;
					if (particle.y < 0) particle.y = 400;
					if (particle.y > 400) particle.y = 0;
					
					// Pulse opacity based on RMS
					particle.opacity = 0.3 + rms * 0.7;
				});
				
				// Draw everything
				draw();
				
				animationId = requestAnimationFrame(animate);
			}
			
			// Initialize everything when page loads
			document.addEventListener('DOMContentLoaded', () => {
				initCanvas();
				initAudio();
				initFFmpeg();
			});
		</script>
	</body>
</html> 